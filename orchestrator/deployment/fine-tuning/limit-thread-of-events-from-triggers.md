# Ограничение потока событий от триггеров 

В версии Оркестратора 23.11 добавлена возможность ограничить исходный поток событий от триггеров при его обработке. Настройка помогает устранить либо снизить риск отказа в обслуживании.

Ограничить поток значит преобразовать его с помощью промежуточной очереди в поток с меньшей интенсивностью и более высокой предсказуемостью. Преобразование выполняется успешно, если не превышена интегральная характеристика интенсивности исходного потока - подробности см. ниже. 

## Параметры ограничения потока событий

Чтобы настроить ограничение, внесите изменения в конфигурационный файл WebApi. Нужные параметры содержатся в секции `Assignment`:
```
"Assignment": {
    ...
    /* Использовать ограничение для потока событий триггеров (мсек)
       Если 0 - ограничение не используется */
    "ChainLimiterTriggerEventTime": 500,
    /* Использовать ограничение для потока событий триггеров почты */
    "ChainLimiterTriggerEventEmail": true,
    /* Использовать ограничение для потока событий триггеров расписаний */
    "ChainLimiterTriggerEventSchedule": true,
    /* Использовать ограничение для потока событий триггеров запуска из роботов */
    "ChainLimiterTriggerEventFromRobot": true,
    /* Максимальный размер промежуточной очереди, при превышении которого события будут теряться -
       фактически означает отказ в обслуживании */
    "MaxTriggerQueueLength": 10000,
    /* Максимальный интервал (минут) для отображения последних событий уменьшения/увеличения/переполнения
       внутренней очереди на главной странице */
    "MaxLastEventsInterval": 5
  },
```

Параметры:

1. **ChainLimiterTriggerEventTime** - определяет, нужно ли использовать ограничение для потока событий триггеров. Значение задается в миллисекундах, рекомендуется `500`. Если указано `0` – ограничение не используется. Также ограничение не используется, если одновременно установлено `false` для параметров:
   * ChainLimiterTriggerEventEmail;
   * ChainLimiterTriggerEventSchedule;
   * ChainLimiterTriggerEventFromRobot.
3. **ChainLimiterTriggerEventEmail** - определяет, нужно ли использовать ограничение для потока событий триггеров почты. Возможные значения: true/false.
4. **ChainLimiterTriggerEventSchedule** - определяет, нужно ли использовать ограничение для потока событий триггеров расписаний. Возможные значения: true/false.
5. **ChainLimiterTriggerEventFromRobot** - определяет, нужно ли использовать ограничение для потока событий триггеров запуска из роботов. Возможные значения: true/false.
6. **MaxTriggerQueueLength** - максимальный размер промежуточной очереди, при превышении которого события будут теряться – фактически означает отказ в обслуживании.
7. **MaxLastEventsInterval** - максимальный временной интервал для отображения последних событий уменьшения/увеличения/переполнения внутренней очереди на главной странице. Указывается в минутах.

## Как работает ограничение

Рассмотрим подробнее, как работает данное ограничение и как стоит выбирать его параметры.

Пусть на отрезке времени [t0, t9] (рисунок 47, a) на каждом Δt  интенсивность потока событий I = Imax. Будем считать интегральной характеристикой потока событий S сумму всех прямоугольников с основанием Δt и высотой I. В частности, рисунок 47 a) показывает, что система работает на пределе своих возможностей (Imax, Smax), но, с нагрузкой справляется, отказа в обслуживании  не происходит.


[!](<../../../.gitbook/assets1/integral-characteristic-of-flow-of-events.png>)

Рисунок 47 б) показывает, что на отрезке [t3, t6] будет отказ в обслуживании, так как превышено Imax на этом отрезке, и, как следствие, превышена интегральная характеристика интенсивности потока (так как на остальных Δt I = Imax).

Рисунок 47 в) также показывает, что на отрезке [t3, t6] будет отказ в обслуживании, так как превышено Imax на этом отрезке. Но, максимальная интегральная характеристика интенсивности потока не превышена. В этом случае возможно перераспределение нагрузки.
Если система принимает и обрабатывает поток событий по простой схеме (рисунок 48, а), перераспределение нагрузки не используется. Это соответствует значению параметра ChainLimiterTriggerEventTime = 0. Даже без превышения интегральной характеристики интенсивности потока, на пиках система не справится, будет отказ в обслуживании. Контролировать интенсивность для каждого отдельно взятого Δt, которая считается внешним фактором , система принципиально не может.


СХЕМА

При включенном распределении нагрузки (рисунок 48, б), соответствует значению параметра ChainLimiterTriggerEventTime > 0, пики нагрузки примет промежуточная очередь. Преобразованный поток событий по своему построению  на любом Δt будет иметь I ≤ Imax. Таким образом, очередь сгладит пики, и весь поток, возможно, с некоторой задержкой, будет обработан.
Если же максимальная интегральная характеристика интенсивности исходного потока превышена, схема с промежуточной очередью не даст результата – очередь переполнится, события будут теряться , что также равносильно отказу в обслуживании.
Для числовой оценки интегральной характеристики интенсивности потока можно использовать лог событий оркестратора – таблица OrchEvent, одно из трех значений поля Event: 
•	AssignmentIncreaseTriggerNativeEventBus = 9016 – внутренняя очередь увеличивается;
•	AssignmentDecreaseTriggerNativeEventBus = 9017 – внутренняя очередь уменьшается;
•	AssignmentOverflowTriggerNativeEventBus = 9018 – внутренняя очередь переполнена;
и поле EntityId (для событий увеличения/уменьшения внутренней очереди). Эти события могут быть записаны не чаще, чем с интервалом ChainLimiterTriggerEventTime, так как их наступление проверяется при каждом просыпании потока сбора событий из промежуточной очереди. 

Поле EntityId показывает, как меняется процент от MaxTriggerQueueLength (фиксированные значения: 1 – 25%, 2 – 50%, 3 – 75% ) использования промежуточной очереди. Событие наступает при переходе вверх/вниз одного из 3-х переходов: 25%, 50%, 75%. Так как промежуточная очередь принимает на себя исходный поток событий, по динамике процента её использования во времени можно оценить интегральную характеристику интенсивности этого потока. 
На основе этой оценки можно выбрать приемлемые значения параметров ChainLimiterTriggerEventTime и MaxTriggerQueueLength. А также выработать рекомендации по снижению интенсивности исходного потока событий за счет уменьшения частоты срабатывания триггеров (перенастройка параметров заданий).
Рассмотрим пример оценки интегральной характеристики интенсивности исходного потока на основе лога событий Оркестратора (таблица 20) . Пусть система работает с параметрами ChainLimiterTriggerEventTime=500 и MaxTriggerQueueLength=20 . В логе не зафиксировано событие переполнения внутренней очереди – иначе это бы означало отказ в обслуживании, и детальный анализ лога на предмет интенсивности тут уже был не нужен. 
Анализ проведем на основе временного окна в 20 сек – выберем события, которые попали в это окно. Пусть это будут 4 события :
SELECT "OrchTimestampUtc",
       	"Event", 
"EntityId" 
FROM "OrchEvents"
WHERE "Event" in (9016, 9017, 9018) 
  	AND "OrchTimestampUtc" BETWEEN '2023-11-10 11:00:00' AND '2023-11-10 12:00:00'
	AND "NodeId"  = 0
ORDER BY "OrchTimestampUtc" ASC;

## Таблица 2 – Лог событий увеличения/уменьшения процента использования внутренней очереди событий от триггеров


Так как Δt = ChainLimiterTriggerEventTime = 500, тогда таблица 20 преобразуется в таблицу 21 (нумерация строк с 0) – интенсивность исходного потока событий:
Таблица 21 – Интенсивность исходного потока событий от триггеров.


ТАБЛИЦА


Очередь разбирается с интенсивностью 1 сообщение в 500 мсек. За одно обращение из очереди читается не более одного элемента. По таблице 21 видно, что:
После 1-го роста очереди на 25% (№п/п 0 – 7), что значит более 5 (но менее 10) элементов в очереди, до следующего уменьшения из очереди читается 8 элементов. Так как событие уменьшения очереди зафиксировано после чтения 8 элементов, значит очередь в этот промежуток принимала события.
После 1-го уменьшения очереди на 25% (№п/п 8 – 11), что значит менее 5 элементов в очереди, до следующего роста из очереди читается 4 элемента. Те элементы, которые были в очереди на момент фиксации её уменьшения на этом промежутке вычитаны полностью. Но, так сразу следом идет увеличение очереди, это опять говорит о том, что очередь в этот промежуток принимала события.
После 2-го роста очереди на 25% (№п/п 12 – 19), что значит более 5 элементов в очереди, до следующего уменьшения из очереди читается 8 элементов. Так как событие уменьшения очереди зафиксировано после чтения 8 элементов, значит очередь и в этот промежуток принимала события.
После 2-го уменьшения очереди на 25% (№п/п 20) таблица заканчивается, но, очередь в этот момент не пустая.
Таким образом, имеем 2 25%-ных пика интенсивности, которые приняла на себя очередь. В целом интенсивность исходного потока не является для системы критической, но обработка событий идет с небольшой (примерно 5 элементов) задержкой. В данном случае, если у системы есть запас мощности, можно уменьшить ChainLimiterTriggerEventTime, и события будут извлекаться на обработку чаще, внутренняя очередь будет расти медленнее, возможно, её рост даже не будет зафиксирован в логе. Увеличивать MaxTriggerQueueLength не имеет смысла, так как пики не высокие – 25%. 

